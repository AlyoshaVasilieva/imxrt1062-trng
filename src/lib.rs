#![no_std]

use core::fmt::{Debug, Formatter};

use imxrt_ral as ral;
use ral::ccm;
use ral::trng;
use ral::{modify_reg, read_reg, write_reg};
use rand_core::block::{BlockRng, BlockRngCore};
use rand_core::{Error, RngCore};

// warning: written based on the SDK as I do not have access to the Security Reference Manual

/// TRNG sampling mode
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum SampleMode {
    /// von Neumann data in both entropy shifter and statistical checker
    VonNeumann = trng::MCTL::SAMP_MODE::RW::SAMP_MODE_0,
    /// Raw data in both entropy shifter and statistical checker. Likely lower quality than the
    /// other two modes.
    Raw = trng::MCTL::SAMP_MODE::RW::SAMP_MODE_1,
    /// von Neumann data in entropy shifter, raw data in statistical checker
    VonNeumannRaw = trng::MCTL::SAMP_MODE::RW::SAMP_MODE_2,
}

impl Default for SampleMode {
    /// Returns `VonNeumannRaw`.
    fn default() -> Self {
        // "Set sample mode of the TRNG ring oscillator to Von Neumann, for better random data.
        // It is optional." <- SDK, explaining why they set sample mode to 0 (VN)
        // However, Teensyduino uses VN + Raw; the reason for this appears to be this post:
        // https://forum.pjrc.com/threads/54711-Teensy-4-0-First-Beta-Test?p=195000&viewfull=1#post195000
        // which found that VN + Raw seems to results in better random quality.
        // As such, VonNeumannRaw is the default SampleMode here.
        Self::VonNeumannRaw
    }
}

/// iMXRT1062 True Random Number Generator.
///
/// "The entropy generated by a TRNG is intended for direct use by functions that generate
/// secret keys, per-message secrets, random challenges, and other similar quantities used in
/// cryptographic algorithms." -NXP
#[derive(Debug)]
pub struct TRNG(BlockRng<TRNGCore>); // newtype to allow documentation/potential future extras

impl RngCore for TRNG {
    #[inline]
    fn next_u32(&mut self) -> u32 {
        self.0.next_u32()
    }

    #[inline]
    fn next_u64(&mut self) -> u64 {
        self.0.next_u64()
    }

    #[inline]
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.0.fill_bytes(dest)
    }

    #[inline]
    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        self.0.try_fill_bytes(dest)
    }
}

/// BlockRngCore implementation of the TRNG
struct TRNGCore {
    trngi: trng::Instance,
}

impl Debug for TRNGCore {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("TRNGCore").finish()
    }
}

impl BlockRngCore for TRNGCore {
    type Item = u32;
    type Results = [u32; 16];

    fn generate(&mut self, results: &mut Self::Results) {
        let mut mctl;
        loop {
            mctl = read_reg!(trng, self.trngi, MCTL);
            if (mctl & trng::MCTL::ERR::mask) != 0 {
                write_reg!(trng, self.trngi, MCTL, mctl); // error, write reg back to clear
            } // Teensyduino continues on error, SDK returns error, we wait for good data.
            if (mctl & trng::MCTL::ENT_VAL::mask) != 0 {
                break; // we have entropy ready to read
            }
            core::sync::atomic::spin_loop_hint(); // is this useful?
        }
        results[0] = read_reg!(trng, self.trngi, ENT0, ENT);
        results[1] = read_reg!(trng, self.trngi, ENT1, ENT);
        results[2] = read_reg!(trng, self.trngi, ENT2, ENT);
        results[3] = read_reg!(trng, self.trngi, ENT3, ENT);
        results[4] = read_reg!(trng, self.trngi, ENT4, ENT);
        results[5] = read_reg!(trng, self.trngi, ENT5, ENT);
        results[6] = read_reg!(trng, self.trngi, ENT6, ENT);
        results[7] = read_reg!(trng, self.trngi, ENT7, ENT);
        results[8] = read_reg!(trng, self.trngi, ENT8, ENT);
        results[9] = read_reg!(trng, self.trngi, ENT9, ENT);
        results[10] = read_reg!(trng, self.trngi, ENT10, ENT);
        results[11] = read_reg!(trng, self.trngi, ENT11, ENT);
        results[12] = read_reg!(trng, self.trngi, ENT12, ENT);
        results[13] = read_reg!(trng, self.trngi, ENT13, ENT);
        results[14] = read_reg!(trng, self.trngi, ENT14, ENT);
        results[15] = read_reg!(trng, self.trngi, ENT15, ENT);
        // TODO: learn to write macros, I bet one can do this
        // can also easily be done using unsafe
        read_reg!(trng, self.trngi, ENT0, ENT);
        // SDK (fsl_trng.c):
        //     Dummy read. Defect workaround.
        //     TRNG could not clear ENT_VAL flag automatically, application
        //     had to do a dummy reading operation for anyone TRNG register
        //     to clear it firstly, then to read the RTENT0 to RTENT15 again
        // Teensyduino doesn't do this; is it unnecessary? Only bugged on a different chip?
    }
}

/// Initialize the True Random Number Generator.
pub fn init(ccmi: &ccm::Instance, trngi: trng::Instance, mode: SampleMode) -> TRNG {
    // TODO: TRNG can be locked to prevent programmability (SEC_CFG)
    // some other things here are also likely configurable; however, without access to the SRM,
    // it isn't safe to allow configuration. Garbage configs lead to infinite errors, preventing use

    // TRNG_Init:
    modify_reg!(ccm, ccmi, CCGR6, CG6: 3); // trng_clk_enable - appears to be already set on T4
    write_reg!(trng, trngi, MCTL, PRGM: 1, RST_DEF: 1);
    // enter program mode and reset to defaults (it isn't clear what defaults it actually sets)
    // RST_DEF can be written simultaneously; SDK says so even though it doesn't do it

    // TRNG_GetDefaultConfig / trng_ApplyUserConfig:

    // defaults are sourced from:
    // mcuxpresso SDK folder/devices/MIMXRT1062/drivers/fsl_trng.c
    // and
    // mcuxpresso SDK folder/boards/evkmimxrt1060/driver_examples/trng/random/trng_random.c
    //
    // search for "Initialize TRNG configuration structure to default" in trng_random to find the
    // configuration example.
    // see also https://mcuxpresso.nxp.com/api_doc/dev/1407/a00079.html#a00469 for some vague docs,
    // but note that its listed default value for retry count is wrong (so don't trust it for others)
    write_reg!(trng, trngi, SCMISC, RTY_CT: 1, LRUN_MAX: 34); // DEFAULT_RETRY_COUNT, _RUN_MAX_LIMIT

    // NOTE: SDK has _MAX and _MIN but actual registers use _MAX and _RNG (range), where the range
    // is the max - min. See trng_SetStatisticalCheckLimit in fsl_trng.c
    // Note also: The minimums in the SDK are defined as (max - range), e.g.
    // #define TRNG_USER_CONFIG_DEFAULT_MONOBIT_MAXIMUM 1384
    // #define TRNG_USER_CONFIG_DEFAULT_MONOBIT_MINIMUM (TRNG_USER_CONFIG_DEFAULT_MONOBIT_MAXIMUM - 268)
    // for a minimum of 1116. Since we're working with the registers I'm using the ranges directly.
    write_reg!(trng, trngi, SCM, MONO_MAX: 1384, MONO_RNG: 268); // _MONOBIT_
    write_reg!(trng, trngi, SCR1, RUN1_MAX: 405, RUN1_RNG: 178); // _RUNBIT1_
    write_reg!(trng, trngi, SCR2, RUN2_MAX: 220, RUN2_RNG: 122); // _RUNBIT2_
    write_reg!(trng, trngi, SCR3, RUN3_MAX: 125, RUN3_RNG: 88); // _RUNBIT3_
    write_reg!(trng, trngi, SCR4, RUN4_MAX: 75, RUN4_RNG: 64); // _RUNBIT4_
    write_reg!(trng, trngi, SCR5, RUN5_MAX: 47, RUN5_RNG: 46); // _RUNBIT5_
    write_reg!(trng, trngi, SCR6P, RUN6P_MAX: 47, RUN6P_RNG: 46); // _RUNBIT6PLUS_

    write_reg!(trng, trngi, PKR, PKR_MAX: 26912); // _POKER_MAXIMUM
    write_reg!(trng, trngi, PKRRNG, PKR_RNG: 2467);

    write_reg!(trng, trngi, FRQ, FRQ_MAX: 25600); // _FREQUENCY_MAXIMUM
    write_reg!(trng, trngi, FRQMIN, FRQ_MIN: 1600); // _FREQUENCY_MINIMUM

    write_reg!(trng, trngi, SDCTL, SAMP_SIZE: 2500, ENT_DLY: 3200); // _SAMPLE_SIZE, _ENTROPY_DELAY
    write_reg!(trng, trngi, SBLIM, SB_LIM: 63); // _SPARSE_BIT_LIMIT

    // back in TRNG_Init:
    write_reg!(trng, trngi, MCTL, SAMP_MODE: mode as u32); // exit program mode, set sample mode

    read_reg!(trng, trngi, ENT15, ENT);
    // reading ENT15 wipes all entropy generated and begins new generation; this is a reset.
    // doesn't *seem* to be necessary here (maybe only if users will Init/Deinit/Init?)
    // but the SDK does it unconditionally after setting run mode, so reproduced here
    TRNG(BlockRng::new(TRNGCore { trngi }))
}
